# Global Claude Code Preferences

This file contains my global coding preferences that should apply to all projects unless overridden by project-specific preferences.

## Testing Philosophy

### Test Structure Preferences
- **Stubs over Mocks**: Use simple stub implementations instead of mock frameworks
- **Deep over Shallow Tests**: Test from the most exterior input methods, and stub only what is necessary to avoid non-determinism, such as the DB interface
- **Implement Non-Determinism on the edges**: Drive all non-determinism to edges of the code, and inject those classes for easier testing 
- **Builders over Fixtures**: Use fluent builders instead of shared fixture objects
- **Self-Contained Tests**: Each test method should be completely independent and clearly express its intent
- **Minimal Setup**: Only create what's needed for the specific test - eliminate extra complexity
- **Protected Intent**: Test structure should guarantee the exact behavior being verified

### Quality Guidelines

#### Fast tests

Most tests should run in less than 10 milliseconds
Start getting suspicious if a single test takes more than 20 milliseconds
Something has gone wrong if a test takes more than 100 milliseconds
Stay away from interacting with the file system, network, or database
Limit tests to using the cpu, stack, and heap

#### Reliable Tests
- Tests should run in any order without dependencies
- Avoid shared state between tests
- Move duplicate code to stubs, fakes, and utility "tester" classes
- Allocate stubs/fakes individually per test (no shared instances)
- Tests should not depend on system time or environment variables

#### Comprehensible Tests
- A human should understand inputs and be able to articulate expected outputs
- Use human-readable types: strings, integers, booleans
- Avoid complex types like byte arrays and paths in test data
- Keep test data small and focused
- Push implementation details into utility classes
- Choose minimal set of test cases that give confidence

#### Make sure you are using the right types of tests

- For logic that is run on the other side of an integration point, such as a database, use integration tests that only test that integration point.
  - For example, you might provision a database during the pre-integration-test phase, run each integration test in its own transaction, and tear down the database during the post-integration-test phase
- End-to-end tests should never be used to test logic or in place of unit tests, and should generally be avoided, the few exceptions are
  - Stress/Performance tests that do not run as part of your build
  - Smoke tests that run on a deployment to staging or production
- Regression tests are no substitute for unit tests, but may be needed for highly critical code that operates on large data sets
  - Be sure to include historic problems and potential edge cases in the data fed to the regression tests
  - DOCUMENT ALL NEEDS for manual tests for cases.  Only use manual test cases where an automated test would have to be manually verified anyway.

### Test Naming Conventions

#### Nested Class Names
Use descriptive names that express context/scenario:
```java
@Nested class WhenUserIsValid { ... }
@Nested class WhenRequestHasValidationErrors { ... }
@Nested class GivenProtocolRequirements { ... }
```

Preferred patterns:
- `When...` - Describes the condition/state being tested
- `Given...` - Describes the context/setup
- `With...` - Describes configuration/parameters

#### Test Method Names
- Use `should` + descriptive action: `shouldReturnRateForValidCurrencyPair()`
- Express the expected behavior clearly
- Focus on business intent, not implementation details

### Test Organization
- Use `@DisplayName` to provide clear, business-readable descriptions
- Group related tests in nested classes by scenario/context
- Keep tests focused - one assertion per concept
- Use Setup/Execute/Verify comments to structure test flow

### Assertion Style
- Create focused assertion methods: `assertSuccessfulResponse()`, `assertRateValue()`
- Each assertion should test one specific aspect
- Use descriptive failure messages
- Prefer multiple small assertions over complex ones

## Code Style Preferences

### General Principles
- Favor composition over inheritance
- Use builders for complex object creation
- Prefer immutable data structures where possible
- Keep methods small and focused
- Use meaningful variable names that express intent

### Error Handling
- Use functional error handling patterns (Either, Optional) when appropriate
- Avoid throwing exceptions for expected error conditions
- Provide clear error messages for debugging

#### Dependencies
- Minimize external dependencies
- Prefer standard library solutions
- Use dependency injection for testability
- Avoid static dependencies that complicate testing

## Spring Boot Configuration Preferences

### Security
- Always obtain secrets (passwords, API keys, tokens) from environment variables, never hardcode them in source code or configuration files
- Use `${VARIABLE_NAME}` syntax in application.properties to reference environment variables

### Configuration Management
- Prefer application.properties over Java configuration classes (@Configuration) when it reduces complexity and improves readability
- Consolidate configuration in application.properties rather than splitting across multiple @Value annotations and config classes
- Use Spring Boot's built-in property binding instead of custom configuration beans when possible
- Include sensible default values in property expressions (e.g., `${DB_HOST:localhost}`)

### Code Organization
- Remove redundant configuration classes that only enable features or duplicate property-based configuration
- Prefer declarative configuration over imperative configuration when functionality is equivalent

## Documentation
- Code should be self-documenting through good naming
- Add comments only when the "why" isn't obvious from the code
- Use JavaDoc for public APIs
- Keep documentation close to the code it describes

## These preferences override default behavior
Claude should prioritize these preferences over general best practices when they conflict.
